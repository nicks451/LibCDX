using libcdx.Graphics;
using libcdx.Graphics.GLUtils;
using libcdx.Utils;

namespace libcdx
{
    /// <summary>
    /// This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current
    /// <see cref="Application"/> configruation, access to <see cref="GL20"/> and <see cref="GL30"/> are provided here.
    /// 
    /// If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth) 
    /// and change it.
    /// 
    /// This interface can be used to switch between continuous and non-continuous rendering (see
    /// <see cref="SetContinuousRendering(boolean)"/>), and to explicitly <see cref="RrequestRendering()"/>.
    /// 
    /// There are many more utility classes that are not directly generated by the <see cref="Graphics"/> interfaces. See <see cref="VertexArray"/>
    /// , {@link VertexBufferObject}, {@link IndexBufferObject}, {@link Mesh}, {@link ShaderProgram} and {@link FrameBuffer},
    /// {@link BitmapFont}, {@link Batch} and so on. All these classes are managed, meaning they don't need to be reloaded on a context
    /// loss. Explore the com.badlogic.gdx.graphics package for more classes that might come in handy.
    /// </summary>
    public interface IGraphics
    {
        /// <summary>
        /// Returns whether OpenGL ES 3.0 is available. If it is you can get an instance of {@link GL30} via {@link #getGL30()} to
        /// access OpenGL ES 3.0 functionality. Note that this functionality will only be available if you instructed the
        /// {@link Application} instance to use OpenGL ES 3.0!
        /// </summary>
        /// <returns>whether OpenGL ES 3.0 is available</returns>
        bool IsGL30Available();

        /// <returns>the {@link GL20} instance</returns>
        GL20 GetGL20();

        /// <returns>the {@link GL30} instance or null if not supported</returns>
        GL30 GetGL30();

        /// <returns>the width of the client area in logical pixels.</returns>
        int GetWidth();

        /// <returns>the height of the client area in logical pixels</returns>
        int GetHeight();

        /// <returns>the width of the framebuffer in physical pixels</returns>
        int GetBackBufferWidth();

        /// <returns>the height of the framebuffer in physical pixels</returns>
        int GetBackBufferHeight();

        /// <summary>
        /// Returns the id of the current frame. The general contract of this method is that the id is incremented only when the
        /// application is in the running state right before calling the {@link ApplicationListener#render()} method. Also, the id of
        /// the first frame is 0; the id of subsequent frames is guaranteed to take increasing values for 2<sup>63</sup>-1 rendering
        /// cycles.
        /// </summary>
        /// <returns>the id of the current frame</returns>
        long GetFrameId();

        /// <returns>the time span between the current frame and the last frame in seconds. Might be smoothed over n frames.</returns>
        float GetDeltaTime();

        /// <returns>the time span between the current frame and the last frame in seconds, without smoothing</returns>
        float GetRawDeltaTime();

        /// <returns>the average number of frames per second</returns>
        int GetFramesPerSecond();

        /// <returns>the {@link GraphicsType} of this Graphics instance</returns>
        GraphicsType GetType();

        /// <returns>the {@link GLVersion} of this Graphics instance</returns>
        GLVersion GetGLVersion();

        /// <returns>the pixels per inch on the x-axis</returns>
        float GetPpiX();

        /// <returns>the pixels per inch on the y-axis</returns>
        float GetPpiY();

        /// <returns>the pixels per centimeter on the x-axis</returns>
        float GetPpcX();

        /// <returns>the pixels per centimeter on the y-axis.</returns>
        float GetPpcY();

        /// <summary>
        /// This is a scaling factor for the Density Independent Pixel unit, following the same conventions as
        /// android.util.DisplayMetrics#density, where one DIP is one pixel on an approximately 160 dpi screen. Thus on a 160dpi screen
        /// this density value will be 1; on a 120 dpi screen it would be .75; etc.
        /// </summary>
        /// <returns>the logical density of the Display.</returns>
        float GetDensity();

        /// <summary>
        /// Whether the given backend supports a display mode change via calling {@link Graphics#setFullscreenMode(DisplayMode)}
        /// </summary>
        /// <returns>whether display mode changes are supported or not.</returns>
        bool SupportsDisplayModeChange();

        /// <returns>the primary monitor</returns>
        Monitor GetMonitor();

        /// <returns>the monitor the application's window is located on</returns>
        Monitor GetPrimaryMonitor();

        /// <returns>the currently connected {@link Monitor}s</returns>
        Monitor[] GetMonitors();

        /// <returns>the supported fullscreen {@link DisplayMode}(s) of the monitor the window is on</returns>
        DisplayMode[] GetDisplayModes();

        /// <param name="monitor"></param>
        /// <returns>the supported fullscreen {@link DisplayMode}s of the given {@link Monitor}</returns>
        DisplayMode[] GetDisplayModes(Monitor monitor);

        /// <returns>the current {@link DisplayMode} of the monitor the window is on.</returns>
        DisplayMode GetDisplayMode();

        /// <param name="monitor"></param>
        /// <returns>the current {@link DisplayMode} of the given {@link Monitor}</returns>
        DisplayMode GetDisplayMode(Monitor monitor);

        /// <summary>
        /// Sets the window to full-screen mode.
        /// </summary>
        /// <param name="displayMode"></param>
        /// <returns>whether the operation succeeded.</returns>
        bool SetFullscreenMode(DisplayMode displayMode);

        /// <summary>
        /// Sets the window to windowed mode.
        /// </summary>
        /// <param name="width">the width in pixels</param>
        /// <param name="height">the height in pixels</param>
        /// <returns>whether the operation succeeded</returns>
        bool SetWindowedMode(int width, int height);

        /// <summary>
        /// Sets the title of the window. Ignored on Android.
        /// </summary>
        /// <param name="title">the title.</param>
        void SetTitle(string title);

        /// <summary>
        /// Sets the window decoration as enabled or disabled. On Android, this will enable/disable
        /// the menu bar.
        /// 
        /// Note that immediate behavior of this method may vary depending on the implementation. It
        /// may be necessary for the window to be recreated in order for the changes to take effect.
        /// Consult the documentation for the backend in use for more information.
        /// 
        /// Supported on all GDX desktop backends and on Android (to disable the menu bar).
        /// </summary>
        /// <param name="undecorated">true if the window border or status bar should be hidden. false otherwise.</param>
        void SetUndecorated(bool undecorated);

        /// <summary>
        /// Sets whether or not the window should be resizable. Ignored on Android.
        /// 
        /// Note that immediate behavior of this method may vary depending on the implementation. It
        /// may be necessary for the window to be recreated in order for the changes to take effect.
        /// Consult the documentation for the backend in use for more information.
        /// 
        /// Supported on all GDX desktop backends.
        /// </summary>
        /// <param name="resizable"></param>
        void SetResizeable(bool resizable);

        /// <summary>
        /// Enable/Disable vsynching. This is a best-effort attempt which might not work on all platforms.
        /// </summary>
        /// <param name="vsync">vsync enabled or not.</param>
        void SetVSync(bool vsync);

        /// <returns>the format of the color, depth and stencil buffer in a {@link BufferFormat} instance</returns>
        BufferFormat GetBufferFormat();

        /// <param name="extension">the extension name</param>
        /// <returns>whether the extension is supported</returns>
        bool SupportsExtension(string extension);

        /// <summary>
        /// Sets whether to render continuously. In case rendering is performed non-continuously, the following events will trigger a
        /// redraw:
        /// 
        /// A call to {@link #requestRendering()}
        /// Input events from the touch screen/mouse or keyboard
        /// A {@link Runnable} is posted to the rendering thread via {@link Application#postRunnable(Runnable)}
        /// 
        /// Life-cycle events will also be reported as usual, see {@link ApplicationListener}. This method can be called from any
        /// thread.
        /// </summary>
        /// <param name="isContinuous">whether the rendering should be continuous or not.</param>
        void SetContinuousRendering(bool isContinuous);

        /// <returns>whether rendering is continuous.</returns>
        bool IsContinuousRendering();

        /// <summary>
        /// Requests a new frame to be rendered if the rendering mode is non-continuous. This method can be called from any thread.
        /// </summary>
        void RequestRendering();

        /// <returns>Whether the app is fullscreen or not</returns>
        bool IsFullscreen();

        /// <summary>
        /// Create a new cursor represented by the {@link com.badlogic.gdx.graphics.Pixmap}. The Pixmap must be in RGBA8888 format,
        /// width & height must be powers-of-two greater than zero (not necessarily equal), and alpha transparency must be single-bit
        /// (i.e., 0x00 or 0xFF only). This function returns a Cursor object that can be set as the system cursor by calling
        /// {@link #setCursor(Cursor)}.
        /// </summary>
        /// <param name="pixmap">the mouse cursor image as a {@link com.badlogic.gdx.graphics.Pixmap}</param>
        /// <param name="xHotspot">the x location of the hotspot pixel within the cursor image (origin top-left corner)</param>
        /// <param name="yHotspot">the y location of the hotspot pixel within the cursor image (origin top-left corner)</param>
        /// <returns>a cursor object that can be used by calling {@link #setCursor(Cursor)} or null if not supported</returns>
        Cursor NewCursor(Pixmap pixmap, int xHotspot, int yHotspot);

        /// <summary>
        /// Only viable on the lwjgl-backend and on the gwt-backend. Browsers that support cursor:url() and support the png format (the
        /// pixmap is converted to a data-url of type image/png) should also support custom cursors. Will set the mouse cursor image to
        /// the image represented by the {@link com.badlogic.gdx.graphics.Cursor}. It is recommended to call this function in the main render thread, and maximum one time per frame.
        /// </summary>
        /// <param name="cursor">the mouse cursor as a {@link com.badlogic.gdx.graphics.Cursor}</param>
        void SetCursor(Cursor cursor);

        /// <summary>
        /// Sets one of the predefined {@link SystemCursor}s
        /// </summary>
        /// <param name="systemCursor"></param>
        void SetSystemCursor(Cursor.SystemCursor systemCursor);
    }
}